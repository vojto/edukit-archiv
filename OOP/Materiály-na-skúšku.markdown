<p><a href="http://u.cwls.info/uploads/OOP%20-skuska.pdf">Otazky na skúšku</a> (staršie, pre C#)</p><p>Materiály ohľadom <a href="http://hron.fei.tuke.sk/~cenkner/OOP/DiagramTriedTahak.pdf">UML</a> a staršie <a href="http://hron.fei.tuke.sk/~cenkner/OOP/OtazkyZoSkuskyAZapoctov-2008.doc">testy</a> zo skúšky a zápočtov (rok 2008, formát doc).</p><p><a href="http://u.cwls.info/uploads/UML%20Quick%20Reference%20Card.pdf">UML Cheatsheet</a></p><hr /><h3>0. Úlohy z minulých rokov (ešte v C#, ale celkom zaujímavé :))</h3><blockquote><hr /><h3>1.  Čo je abstraktný údajový typ (AUT)?</h3><p><font color="red"> AUT je spojenie údajového typu a všetkých povolených operácií s týmto typom </font></p><p> AUT je základný údajový typ programovacích jazykov objektového programovania slúžiaci na definovanie objektov pomocou definičného príkazu abstract</p><p> AUT je základný údajový typ programovacích jazykov objektového programovania slúžiaci výlučne na definovanie vstavaných číselných a reťazcových dátových typov (int, float, string,&hellip;)</p><p> AUT je údajový typ jazyka C++ vhodný pre ukladanie premenných ľubovoľného typu</p><p> AUT je formálny prostriedok pre ohraničenie a spojenie vlastností a správania objektov, subjektov a javov</p><hr /><h3>2.  Ako je implementovaný abstraktný údajový typ (AUT) v programovacích jazykoch?</h3><p><font color="red"> V jazykoch objektového programovania je AUT implementovaný pomocou triedy </font></p><p><font color="red"> V jazykoch štruktúrovaného programovania, ktoré majú prostriedky pre vytváranie modulov, je možné AUT implementovať pomocou modulu, ktorý obsahuje definíciu všetkých premenných a podprogramov, ktoré tieto premenné používajú </font></p><p> V jazykoch štruktúrovaného programovania, ako je napr. jazyk C, je AUT implementovaný pomocou záznamov s prekrývajúcimi sa zložkami, napr. v jazyku C je to pomocou typu union</p><p> V jazykoch objektového programovania je AUT implementovaný len pomocou abstraktnej triedy</p><p> V jazykoch objektového programovania je AUT implementovaný nie len pomocou abstraktných tried, ale aj pomocou rozhraní</p><hr /><h3>3.  Jednoduché dedenie je také, v ktorom:</h3><p><font color="red"> Novo definovaná trieda musí mať práve jednu bázovú (rodičovskú) triedu </font></p><p> Novo definovaná trieda musí mať práve jeden zdedený člen (členskú funkciu alebo premennú)</p><p> Novo definovaná trieda môže mať najviac jednu bázovú (rodičovskú) triedu</p><p> Novo definovaná trieda môže mať najviac jeden zdedený člen (členskú funkciu alebo premennú)</p><p> Novo definovaná trieda môže mať najviac jedného potomka (pojem potomok znamená inú triedu, ktorá dedí od určeného predka)</p><hr /><h3>4. Dedičnosť pri objektovom programovaní umožňuje:</h3><p><font color="red"> Vytváranie hierarchie tried, v ktorej odvodené triedy môžu mať prístup k niektorým členom nadradených tried </font></p><p><font color="red"> Vytváranie hierarchie tried, v ktorej objekty odvodených tried môžu mať niektoré vlastnosti a správanie také, ako majú objekty nadradených tried </font></p><p> Vytváranie hierarchie tried, v ktorej nadradené triedy môžu mať prístup k verejným (public) a chráneným (protected) členom odvodených tried</p><p> Vytváranie hierarchie tried, v ktorej odvodené triedy musia mať prístup k všetkým členom nadradených tried</p><p> Vytváranie hierarchie tried, v ktorej odvodené triedy nemôžu mať prístup k členom nadradených tried</p><hr /><h3>5. Pre všetky členské funkcie triedy v C++ aj C# platí, že prostredníctvom identifikátora členskej premennej majú viditeľné (pri otázke sa neberú do úvahy modifikátory, napr. static,&hellip;):</h3><p><font color="red"> Všetky dátové členy tried predkov s viditeľnosťou protected </font></p><p><font color="red"> Všetky dátové členy s viditeľnosťou public zo všetkých viditeľných tried toho istého programu a všetky dátové členy vlastnej triedy </font></p><p> Všetky dátové členy všetkých tried toho istého programu</p><p> Len dátové členy tej istej triedy</p><p> Len dátové členy s viditeľnosťou public (z viditeľných tried)</p><hr /><h3>6. Ktorá možnosť označuje všetky podporované modifikátory prístupu v C#?</h3><p><font color="red"> puplic, private, protected, internal, protected internal  </font></p><p> internal protected, internal, public, private   <font color="blue"> //  Nie. Chýba kľúčové slovo „protected“. Za túto odpoveď sa neodpočítava 100% bodov, ale „iba“ 50%, nakoľko je tak trochu „chytákom“ </font></p><p> puplic, private, protected, class, interface     <font color="blue"> //  Nie. „class“ je kľúčové slovo označujúce triedu. „interface“ je kľúčové slovo označujúce rozhranie. Ani jedno z nich nie je modifikátorom prístupu </font></p><p> public, private, protected, internal, external   <font color="blue"> //  Nie. Kľúčové slovo „external“ j jazyku C# nie je </font></p><p> public, private, external, class   <font color="blue"> //  Nie. Kľúčové slovo „external“ v jazyku C# nie je. „class“ je kľúčové slovo označujúce triedu </font></p><hr /><h3>7.  Určte, ktoré definície triedy „Komplex“ sú syntakticky správne!</h3><p><font color="red"> class Komplex {private float re; private float im;} </font></p><p><font color="red"> internal class Komplex {private float re, im;} </font></p><p><font color="red"> public class Komplex {private float re; public float im;} </font></p><p><font color="red"> public class Komplex {public Komplex () { Komplex komplex;}}  </font>  <font color="blue"> //  OK. Public trieda s menom „Komplex“, v nej verejný konštruktor, v tele ktorého sa definuje lokálna premenná s menom „komplex“ typu „Komplex“ </font></p><p> protected class Komplex (private float re; private float im;)   <font color="blue"> //  Nie. Telo triedy musí byť v zložených zátvorkách (nie okrúhlych) </font></p><hr /><h3>8. Čo platí pre členy triedy uvedené za kľúčovým slovom „protected“?</h3><p><font color="red"> Sú prístupné metódam danej triedy a metódam odvodených tried </font></p><p> Sú prístupné len metódam deklarovaným v tej istej triede   <font color="blue"> //  Nie. Toto platí pre členy tried, ktoré sú špecifikované ako „private“ </font></p><p> Sú prístupné podľa pravidiel viditeľnosti štruktúr ako v jazyku C   <font color="blue"> //  Nie. Pravidlá viditeľnosti v jazyku C sú odlišné ako pravidlá viditeľnosti v jazyku C# </font></p><p> Sú prístupné iba cez kľúčové slovo „this“   <font color="blue"> //  Nie. Kľúčové slovo „this“ odkazuje na aktuálny objekt triedy </font></p><p> Sú prístupné iba cez meno triedy, teda sú chránené   <font color="blue"> //  Nie. Cez meno triedy sú prístupné „static“ členy a nie sú tým nijako chránené </font></p><hr /><h3>9. Čo platí pre členy triedy uvedené za kľúčovým slovom „private?</h3><p><font color="red"> Platí pre nich v rámci triedy (class) to isté ako keby nebol uvedený žiadny modifikátor prístupu  </font>   <font color="blue"> //  OK. Implicitne sú všetky členy tried prístupné ako „private“ </font></p><p><font color="red"> Sú prístupné len metódam definovaným v tej istej triede </font></p><p> Sú prístupné metódam danej triedy a metódam odvodených tried   <font color="blue"> //  Nie. Tento spôsob prístupu dosiahneme použitím modifikátora prístupu „protected“ </font></p><p> Sú prístupné podľa pravidiel viditeľnosti zložiek štruktúr ako v jazyku C  </font></p><p> Sú prístupné všetkým metódam tried v tom istom mennom priestore (namespace)   <font color="blue"> //  Nie. Tento spôsob prístupu dosiahneme v jazyku C# použitím modifikátora prístupu „internal“ </font></p><hr /><h3>10. Pri prekrývaní „virtual“ metódy v jazyku C# sa používa kľúčové slovo:</h3><p><font color="red"> override </font></p><p> virtual   <font color="blue"> //  Nie. Toto kľúčové slovo sa používa pre špecifikovanie virtuálnej metódy, ktorá má byť prekrytá. Nie pre samotné prekrytie. </font></p><p> overload   <font color="blue"> //  Nie. Také kľúčové slovo jazyk C# neosahuje </font></p><p> ref   <font color="blue"> //  Nie. Toto kľúčové slovo sa používa pri definovaní parametrov metód a odovzdávaní ich argumentov (odovzdávanie hodnotových typov referenciou) </font></p><p> Nemusí byť žiadne   <font color="blue"> //  Nie. Toto je v jazyku C# zakázané. Táto možnosť prekrytia virtuálnej metódy existuje povedzme v jazyku C++ </font></p><hr /><h3>11. Pri prekrývaní metód (overriding), využívanom pri inkluzívnom polymorfizme, sa v jazyku C# využíva kľúčové slovo:</h3><p><font color="red"> virtual </font>   <font color="blue"> //  OK. Samozrejme, používa sa v spojení s kľúčovým slovom override </font></p><p> overload   <font color="blue"> //  Nie. Takéto kľúčové slovo sa v jazyku C# nenachádza, možno ste si ho pomýlili s kľúčovým slovom override </font></p><p> polymorphism   <font color="blue"> //  Nie. Takéto kľúčové slovo sa v jazyku C# nenachádza. Pre rôzne druhy polymorfizmu existujú v C# rôzne iné jazykové konštrukcie </font></p><p> ref   <font color="blue"> //   Nie. Toto kľúčové slovo sa používa, ak je potrebné odovzdávať hodnotové premenné referenciou </font></p><p> static   <font color="blue"> //  Nie. Toto kľúčové slovo označuje statické členy triedy (tie, ktoré patria triede, nie objektom) </font></p><hr /><h3>12. Pri prekrývaní (overriding) metód platí:</h3><p><font color="red"> Prekrytá metóda má rovnaké meno aj parametre </font>   <font color="blue"> //  OK. Ak chceme metódu prekryť, prekrývajúca metóda musí mať úplne zhodnú signatúru </font></p><p> Prekrytá metóda má rovnaké meno, ale líši sa v počte alebo type parametrov   <font color="blue"> //  Nie. Toto by bol správny výrok o preťažovaní (overloading) </font></p><p> Prekrytá metóda má rovnaké meno, ale líši sa v počte aj type parametrov</p><p> Prekrytá metóda má rovnaké meno a všetky parametre sú implicitné</p><p> Prekrytá metóda má rovnaké meno a nesmie mať žiadne parametre</p><hr /><h3>13. Označte správne výroky o diagramoch sekvencií (SD):</h3><p><font color="red"> Usporiadanie podľa časovej osi je v SD dôležité </font></p><p><font color="red"> SD predstavuje scenár použitia systému alebo jeho častí </font></p><p> V SD je prehľadne viditeľná statická štruktúra systému</p><p> Zo SD je možné vyčítať typy vzťahov medzi objektmi (triedami)</p><p> Úlohou SD je určiť typy dát odovzdávaných medzi objektmi (triedami)</p><hr /><h3>14. Správanie objektu je možné definovať:</h3><p><font color="red"> Pomocou rozhraní, ktoré sú v triede objektu implementované </font></p><p><font color="red"> Pomocou vhodných metód v definícii triedy </font></p><p><font color="red"> Pomocou vhodných členských funkcií v definícii triedy </font></p><p> Pomocou vhodných členských funkcií v definícii objektu</p><p> Pomocou nečlenských funkcií</p><hr /><h3>15. Parametrický polymorfizmus v jazykoch objektového programovania umožňuje:</h3><p><font color="red"> Použiť v definícii šablón tried formálne typové parametre, ktoré budú na mieste definovania triedy nahradené konkrétnym typom alebo triedou </font></p><p> Používať v definícii tried formálne typové parametre, ktoré budú na mieste definovaného objektu nahradené konkrétnym typom alebo triedou</p><p> Používať vo volaní členských funkcií (metód) tried parametre ľubovoľného preddefinovaného typu</p><p> Používať rovnaké identifikátory metód (členských funkcií) pre rôzne operácie s dátovými členmi</p><p> Použitie jednej metódy triedy viacerými spôsobmi</p><hr /><h3>16. Parametrický polymorfizmus v jazykoch objektového programovania umožňuje:</h3><p><font color="red"> Použiť v definícii šablón tried formálne parametre, ktoré budú na mieste definovania triedy nahradené konkrétnym typom alebo triedou </font></p><p> Používať v definícii tried formálne typové parametre, ktoré budú na mieste definovania objektu triedy nahradené konkrétnym typom alebo triedou</p><p> Používať vo volaní členských funkcií (metód) tried parametre ľubovoľného preddefinovaného typu</p><p> Používať rovnaké identifikátory metód (členských funkcií) pre rôzne operácie s dátovými členmi</p><p> Použitie jednej metódy triedy viacerými spôsobmi (s rozličným počtom parametrov)</p><hr /><h3>17. Ad-hoc polymorfizmus „overloading“ v jazykoch objektového programovania umožňuje:</h3><p><font color="red"> Použitie toho istého mena pre rôzne členské funkcie definované v jednej triede </font></p><p><font color="red"> Definovanie viacerých metód s rovnakým identifikátorom (identifikátorom je meno metódy) a rôznou signatúrou (signatúra zahŕňa meno, počet a typ parametrov) v rámci jednej triedy </font></p><p> Používať v definícii tried formálne typové parametre, ktoré budú na mieste definovania objektu triedy nahradené konkrétnym typom alebo triedou</p><p> Používať objekt podtriedy všade tam, kde sa vyžaduje objekt niektorej z jeho nadtried</p><p> Používať rovnaké identifikátory metód (členských funkcií) pre rôzne operácie s dátovými členmi</p><hr /><h3>18. Ktoré štýly komentárov podporuje jazyk C#?</h3><pre><code>//   C++ štýl            &lt;--- spravne<br />/* */   C štýl           &lt;--- spravne<br />///   XML štýl           &lt;--- spravne<br />&lt;!-- --&gt;  HTML štýl </code></pre><hr /><h3>19. Program v jazyku C# sa neprekladá priamo do vykonateľného kódu, ale do tzv. medzijazyka&hellip;</h3><p><font color="red"> MSIL &ndash; MS Intermediate Language </font>   <font color="blue"> // OK. Ozaj &ndash; viete, že skratka „OK“ vznikla z informácií keltských kmeňov vracajúcich sa z boja: „0 killed“ => OK </font></p><p> MSEL &ndash; MS Executable Language   <font color="blue"> //  Toto je vymyslená skratka </font></p><p> MS.NET &ndash; MS.NET Language   <font color="blue"> //  To je skratka niečoho ako Microsoft .NET, čo je vlastne skratka pre .NET platformu, nemá to teda nič spoločné s medzijazykom </font></p><p> Visual C# .NET Language   <font color="blue"> //  Táto skratka označuje jazyk C# a nie medzijazyk </font></p><hr /><h3>20. Čo označuje slovo „System“ vo výraze „System.Console“ v jazyku C#?</h3><p><font color="red"> Menný priestor (namespace) </font>   <font color="blue"> //  OK </font></p><p> Meno odvodenej triedy (inherited class)   <font color="blue"> //  Pri definícii alebo použití dedičnosti sa používa iná syntax. Odvodená trieda je pojem týkajúci sa dedičnosti </font></p><p> Meno základnej triedy (base class)   <font color="blue"> //  Pri definícii alebo použití dedičnosti sa používa iná syntax. Základná trieda je pojem týkajúci sa dedičnosti </font></p><p> Meno statického dátového člena   <font color="blue"> //  Statické dátové členy sa používajú pomocou syntaxe „MenoTriedy.StatickyDatovyClen“ </font></p><p> Názov súboru (file name)   <font color="blue"> //  Nie, názvy súborov, v ktorých sú triedy definované, nie sú v zdrojových súboroch (*.cs) uvedené </font></p><hr /><h3>21. Čo je to konzolová aplikácia?</h3><p><font color="red"> Aplikácia bežiaca v okne bez grafického užívateľského rozhrania (GUI) </font></p><p><font color="red"> Aplikácia, v ktorej programátor využíva pre vstup/výstup služby triedy „System.Console“ </font></p><p> Aplikácia bežiaca v okne s grafickým používateľským rozhraním   <font color="blue"> //  Toto je Windows aplikácia (alebo v .NET WinForms aplikácia) </font></p><p> Aplikácia vykonateľná na PC aj hernej konzole   <font color="blue"> //  No comment </font></p><p> Ľubovoľná aplikácia bežiaca v okne   <font color="blue"> //  Okno môže byť aj grafické Windows okno, nie len okno typu príkazový riadok, ktoré používa konzolová aplikácia </font></p><hr /><h3>22  Čo označujeme ako objekt v objektovom programovaní?</h3><p><font color="red"> Inštancia nejakého typu </font></p><p><font color="red"> Priestor vyhradený na „hromade“ (heap) označený typom </font></p><p> Implementovaná metóda   <font color="blue"> //  Metóda je členom triedy a tým aj inštanciovaného objektu, metóda sama o sebe nie je objektom </font></p><p> Trieda   <font color="blue"> //  Trieda je len predpisom pre objekt </font></p><p> Zdrojový súbor   <font color="blue"> //  Môže byť považovaný za objekt, ale je to len jeden z prípadov, ktoré dokáže objekt modelovať. Objekt vo všeobecnosti dokáže modelovať oveľa viac ako iba „súbor“&hellip; Za túto odpoveď sa neodpočítava 100% bodov, ale „iba“ 80%, nakoľko je tak trochu „chytákom“ </font></p><hr /><h3>23. Nové typy sa v jazyku C# definujú pomocou:</h3><p><font color="red"> Tried </font></p><p> Inštancií   <font color="blue"> //  Inštancia je vytvorená podľa typu, nedefinuje samotný typ </font></p><p> Objektov   <font color="blue"> //  Objekt je len inštancia typu, nie definícia </font></p><p> Typových konštruktorov   <font color="blue"> //  Tento pojem sa asi zaplietol z funkcionálneho programovania, v OOP takýto pojem nemáme (asponň nie pre jazyk C#) </font></p><p> Výrazov   <font color="blue"> //  Vo výrazoch sa typy používajú cez premenné. Ak máme „int a,b“, „(a+b)“ je výraz typu int. Výraz nie je samotnou definíciou typu </font></p><hr /><h3>24. Medzi členy triedy v jazyku C# môžu patriť:</h3><p><font color="red"> Metódy (Methods) </font>   <font color="blue"> //  Áno, členské metódy tried sú členmi tried </font></p><p><font color="red"> Premenné (Fields) </font>   <font color="blue"> //  Áno, členské premenné tried sú členmi tried. Najlepšie je, ak sú privátne. Sú tak dobre zapuzdrené podľa jednej z hlavných myšlienok OOP </font></p><p><font color="red"> Vlastnosti (Properties) </font>   <font color="blue"> //  Áno, v jazyku C# môžu byť členmi tried aj vlastnosti </font></p><p> Menné priestory (Namespaces)   <font color="blue"> //  Nie. Menné priestory slúžia na zgrupovanie tried do skupín. Riešia tak problémy kolízie mien, spájanie súvisiacich tried do celkov atď. </font></p><p> Rozhrania (Interfaces)   <font color="blue"> //  Nie. Rozhrania sú čosi ako oklieštené triedy, obsahujú len predpisy (hlavičky, signatúry) metód, ktoré by triedy mali obsahovať </font></p><hr /><h3>25. Správna syntax pre vytvorenie nového objektu v C# je:</h3><p><font color="red"> Type identifier = new Type () </font></p><p> Type identifier = new Type   <font color="blue"> //  Nie. Chýbajú okrúhle zátvorky (volanie konštruktora) </font></p><p> Type identifier = Type ()   <font color="blue"> //  Nie. Chýba kľúčové slovo „new“ </font></p><p> Type *identifier = new Type ()   <font color="blue"> //  Nie. C# nepoužíva znak „*“ vo význame smerníka ako jazyky C++ alebo C </font></p><p> Type *identifier = new Type   <font color="blue"> //  Nie. C# nepoužíva znak „*“ vo význame smerníka ako jazyky C++ alebo C. Navyše chýbajú krúhle zátvorky (volanie konštruktora) </font></p><hr /><h3>26. Vyznačte správne dokončenie úplnej definície: „Preťažené (overload) metódy sa musia líšiť &hellip;“</h3><p><font color="red"> V počte parametrov alebo v type parametrov </font></p><p> V počte parametrov a v type parametrov   <font color="blue"> //  Nie. Stačí, ak sa lišia len v počte alebo len v type. Za túto odpoveď sa neodpočítava 100% bodov, ale „iba“ 70%, nakoľko je tak trochu „chytákom“ </font></p><p> V názve funkcií (metód)   <font color="blue"> //  Nie. Vtedy by to nebolo ani preťaženie (overload) ani prekrytie (override). Bola by to jednoducho iná funkcia (metóda) </font></p><p> V type parametrov a type návratovej hodnoty   <font color="blue"> //  Nie. Typ návratovej hodnoty musí byť pri preťažených (overload) metódach rovnaká </font></p><p> Začiatok definície nie je správny. Počet, meno aj typ parametrov metódy musí byť pri preťažení (overload) rovnaký   <font color="blue"> //  Nie. Toto je prekrývanie (override) </font></p><hr /><h3>27. Určte správnosť výrokov o konštruktore!</h3><p><font color="red"> Konštruktor je volaný automaticky pri vytváraní objektu triedy, nedá sa neskôr volať priamo ako metóda </font></p><p><font color="red"> Meno konštruktora je vždy rovnaké ako meno triedy </font></p><p><font color="red"> V konštruktore je možné volať statické metódy triedy, ktorej objekt je vytváraný </font></p><p>Konštruktor vracia hodnotu, ktorá indikuje, či bol objekt korektne vytvorený   <font color="blue"> //  Nie. </font></p><p>Konštruktor nič nevracia, dokonca pre neho nedefinujeme ani „void“ návratový typ</p><p>Meno konštruktora je zhodné s názvom súboru, v ktorom je definovaný   <font color="blue"> //  Nie. Môže, ale nemusí byť pravda. Záleží na tom, ako programátor pomenuje súbor </font></p><hr /><h3>28. Určte správnosť výrokov o konštruktore!</h3><p><font color="red"> Konštruktor nesmie mať špecifikovaný typ návratovej hodnoty, dokonca ani „void“ </font></p><p> Existujú špeciálne prípady, kedy meno konštruktora môže byť iné ako meno triedy   <font color="blue"> //  Nie. Meno konštruktora musí byť vždy rovnaké ako meno triedy, inak by to nebol konštruktor, iba obyčajná metóda </font></p><p> Konštruktor môže byť označený aj modifikátorom „virtual“   <font color="blue"> //  Nie. Konštruktor je vlastný len aktuálnej triede, nemôže byť prekrytý v odvodenej triede (override) </font></p><p> Konštruktor jednej triedy môžeme volať aj viackrát pre jeden objekt   <font color="blue"> //  Nie. Konštruktor je volaný pre objekt iba raz a to vtedy, keď je objekt vytváraný </font></p><p> V triede môže byť definovaných niekoľko konštruktorov s rovnakou definíciou</p><hr /><h3>29. Statická metóda „WriteLine“ triedy „Console“ môže byť v jazyku C# volaná pomocou:</h3><p><font color="red"> System.Console.WriteLine(); </font></p><p><font color="red"> using System;   &hellip;    Console.WriteLine();  </font></p><p> System.Console.WriteLine;   <font color="blue"> //  Nie. Chýbajú zátvorky pre volanie metódy </font></p><p> using System;   &hellip;   Console c=new Console; c.WriteLine();   <font color="blue"> //  Nie. Metóda WriteLine je statická, nie inštančná. Nemôžeme ju volať na inštancii </font></p><p> using System.Console;   &hellip;    WriteLine();   <font color="blue"> //  Nie. V klauzule using môže byť použitý iba menný priestor (namespace), nie názov triedy, napr. „Console“ </font></p><hr /><h3>30. Označte správne výroky o triede „Object“:</h3><p><font color="red"> Trieda obsahuje virtuálne metódy (Equals, ToString, Finalize, &hellip;) </font></p><p><font color="red"> Všetky triedy sú implicitne odvodené od triedy „Object“ </font></p><p><font color="red"> Všetky základné údajové typy (Int, Float, &hellip;) sú implicitne odvodené od triedy „Object“ </font>   <font color="blue"> //  OK. Tak ako všetky triedy aj triedy pre dátové typy majú predka „Object“ </font></p><p> Všetky metódy triedy „Object“ musia byť prekryté v jej potomkoch</p><p> Trieda „Object“ je jediným prípadom v .NET, kedy trieda je zároveň objektom (bez vytvárania inštancie)   <font color="blue"> //  Nie. Takáto výnimka neexistuje. Trieda je trieda a objekt je jej inštancia </font></p><hr /><h3>31. Do ktorej oblasti návrhových vzorov patrí vzor Container?</h3><p><font color="red"> Vytváracie vzory </font></p><p> Vzory architektúr</p><p> Vzory paralelizmu</p><p> Vzory správania</p><p> Štrukturálne vzory</p><hr /><h3>32. Do ktorej oblasti návrhových vzorov patrí vzor State?</h3><p><font color="red"> Vzory správania </font></p><p> Vzory architektúr</p><p> Vzory paralelizmu</p><p> Vytváracie vzory</p><p> Štrukturálne vzory</p><hr /><h3>33. Do ktorej oblasti návrhových vzorov patrí vzor Memento?</h3><p><font color="red"> Vzory správania </font></p><p> Vzory architektúr</p><p> Vzory paralelizmu</p><p> Vytváracie vzory</p><p> Štrukturálne vzory</p><hr /><h3>34. Ktorý návrhový vzor je použitý, ak chceme vyberať konkrétny algoritmus dynamicky počas behu programu?</h3><p><font color="red"> Strategy </font></p><p> Composite</p><p> Observer</p><p> Template Method</p><p> Visitor</p><hr /><h3>35. Ktorý návrhový vzor je použitý, ak chceme vytvoriť hierarchickú štruktúru objektov s jednotným rozhraním obsiahnutých objektov?</h3><p><font color="red"> Composite </font></p><p> Decorator</p><p> Facade</p><p> Factory Method</p><p> Object</p><hr /><h3>36. Označte typy vzťahov, ktoré je možné použiť v diagrame tried UML:</h3></blockquote><p><img src="http://hron.fei.tuke.sk/~cenkner/OOP/data/36.png" alt="36.png" /></p><blockquote><p><font color="red"> L </font></p><p><font color="red"> N </font></p><p><font color="red"> P </font></p><p><font color="red"> R </font></p><p> S</p><hr /><h3>37. Označte prvky, ktoré je možné použiť v diagrame tried UML (Class Diagram):</h3></blockquote><p><img src="http://hron.fei.tuke.sk/~cenkner/OOP/data/36.png" alt="37.png" /></p><blockquote><p><font color="red"> U </font></p><p><font color="red"> X </font></p><p> L</p><p> M</p><p> R</p><p> V</p><p> W</p><p> Y</p><hr /><h3>38. Označte prvky, ktoré je možné použiť v diagrame prípadov použitia UML (Use-Case Diagram):</h3></blockquote><p><img src="http://hron.fei.tuke.sk/~cenkner/OOP/data/36.png" alt="38.png" /></p><blockquote><p><font color="red"> M </font></p><p><font color="red"> O </font></p><p><font color="red"> T </font></p><p> L</p><p> N</p><p> Q</p><p> R</p><p> U</p><hr /><h3>39. Označte prvky, ktoré je možné použiť v diagrame sekvencií UML (Sequence Diagram):</h3></blockquote><p><img src="http://hron.fei.tuke.sk/~cenkner/OOP/data/36.png" alt="39.png" /></p><blockquote><p><font color="red"> R </font><br /> J v zvislom smere (tak, ako je znázornená)</p><p> K v zvislom smere (tak, ako je znázornená)</p><p> L</p><p> M</p><p> N</p><p> O</p><p> Q</p><hr /><h3>40. Označte časti sekvenčných diagramov UML, ktoré syntakticky aj logicky majú zmysel:</h3></blockquote><p><img src="http://hron.fei.tuke.sk/~cenkner/OOP/data/40.png" alt="40.png" /></p><blockquote><p><font color="red"> J </font></p><p> H</p><p> I</p><p> K</p><p> L</p><p> M</p><p> N</p><p> O</p><hr /><h3>41. Označte úseky kódu, ktoré sú potrebné pre prekrytie (overriding) metódy m() v triedach podľa uvedeného diagramu tried:</h3></blockquote><p><img src="http://hron.fei.tuke.sk/~cenkner/OOP/data/36.png" alt="36.png" /></p><blockquote><p><font color="red"> Do triedy H treba pridať definíciu „public virtual m(){&hellip;}“ </font></p><p><font color="red"> Do triedy J treba pridať definíciu „public override m(){&hellip;}“ </font></p><p> Do triedy H treba pridať definíciu „public override m(){&hellip;}“</p><p> Do triedy H treba pridať definíciu „public static virtual m(){&hellip;}“</p><p> Do triedy J treba pridať definíciu „public static m(){&hellip;}“</p><hr /><h3>42. Označte správne výroky o zdrojovom kóde, ktorý má byť vytvorený podľa uvedeného diagramu tried (mená, násobnosti a viditeľnosť premenných nie sú podstatné pre správnosť odpovede):</h3></blockquote><p><img src="http://hron.fei.tuke.sk/~cenkner/OOP/data/42.png" alt="42.png" /></p><blockquote><p><font color="red"> Trieda „T6“ musí obsahovať riadok „private T7 t7;“ </font></p><p><font color="red"> Trieda „T7“ musí obsahovať riadok „private T6 t6;“ </font></p><p> Trieda „T6“ musí obsahovať riadok „private T6 t6;“</p><p> Trieda „T7“ musí obsahovať riadok „T7 t7;“</p><p> Trieda „T8“ musí obsahovať riadok „T8 t8;“</p><hr /><h3>43. Označte správne výroky, ak beriete do úvahy vzťahy v uvedenom diagrame tried a nasledovné fakty:</h3></blockquote><ol><li><p>Všetky triedy v diagrame majú definované metódy pre získanie obsahu svojich premenných</p></li><li><p>Existujú správne inicializované objekty všetkých tried (pojem správne inicializované znamená, že referencie medzi objektmi sú nastavené podľa vzťahov v diagrame):</p></li></ol><p><img src="http://hron.fei.tuke.sk/~cenkner/OOP/data/43.png" alt="43.png" /></p><blockquote><p><font color="red"> Z objektu typu „Poschodie“ je možné získať všetky objekty typu „Preukaz“ pre všetkých zamestnancov v kanceláriách na danom poschodí </font></p><p><font color="red"> Z objektu typu „Preukaz“ je možné získať objekt typu „Kancelária“, teda kanceláriu, v ktorej daný zamestnanec s preukazom sedí </font></p><p><font color="red"> Z objektu typu „Kancelária“ je možné získať všetky objekty typu „Preukaz“ pre všetkých zamestnancov v danej kancelárii </font></p><p><font color="red"> Z objektu typu „Zamestnanec“ je možné získať objekt typu „Kancelária“, teda kanceláriu, v ktorej zamestnanec sedí </font></p><p> Z objektu typu „Zamestnanec“ je možné priamo (pomocou volania jedinej metódy) získať objekt typu „Kancelária“, teda kanceláriu, v ktorej zamestnanec sedí</p><hr /><h3>44. Označte správne výroky o vzťahoch v uvedenom diagrame tried UML:</h3></blockquote><p><img src="http://hron.fei.tuke.sk/~cenkner/OOP/data/44.png" alt="44.png" /></p><blockquote><p><font color="red"> Rozhranie „IComparable“ môže byť súčasne implementované v oboch uvedených triedach („Dedina“ a „Dom“) </font></p><p><font color="red"> Trieda „Dedina“ môže implementovať obidve uvedené rozhrania („IEnumerable“ a „IComparable“) spolu </font></p><p><font color="red"> Obidve uvedené rozhrania („IEnumerable“ a „IComparable“) môžu byť súčasne implementované v oboch uvedených triedach („Dedina“ a „Dom“) </font></p><p> Vzťah typu „kompozícia“ uvedený v diagrame spôsobuje, že vzťah medzi triedou „Dom“ a rozhraním „IEnumerable“ je nesprávny</p><p> Vzťah typu „závislosť“ uvedený v diagrame spôsobuje, že vzťah medzi triedou „Dom“ a rozhraním „IEnumerable“ je nesprávny</p></blockquote><br />